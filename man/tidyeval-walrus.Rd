% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-tidyeval-walrus.R
\name{tidyeval-walrus}
\alias{tidyeval-walrus}
\alias{`:=`}
\title{\verb{:=} Operator}
\description{
See below
}
\section{Forcing names}{



When a function takes multiple named arguments
(e.g. \code{dplyr::mutate()}), it is difficult to supply a variable as
name. Since the LHS of \code{=} is \link[rlang:nse-defuse]{defused}, giving the name
of a variable results in the argument having the name of the
variable rather than the name stored in that variable. This problem
of forcing evaluation of names is exactly what the \verb{!!} operator is
for.

Unfortunately R is very strict about the kind of expressions
supported on the LHS of \code{=}. This is why rlang interprets the
walrus operator \verb{:=} as an alias of \code{=}. You can use it to supply
names, e.g. \code{a := b} is equivalent to \code{a = b}. Since its syntax is
more flexible you can also force names on its LHS:\preformatted{name <- "Jane"

list2(!!name := 1 + 2)
exprs(!!name := 1 + 2)
}

Like \code{=}, the \verb{:=} operator expects strings or symbols on its LHS.

Since unquoting names is related to interpolating within a string
with the glue package, we have made the glue syntax available on
the LHS of \verb{:=}:\preformatted{list2("{name}" := 1)
tibble("{name}" := 1)
}

You can also interpolate defused function arguments with double
braces \verb{\{\{}, similar to the curly-curly syntax:\preformatted{wrapper <- function(data, var) {
  data \%>\% mutate("{{ var }}_foo" := {{ var }} * 2)
}
}

Currently, forcing names with \verb{:=} only works in top level
expressions. These are all valid:\preformatted{exprs("{name}" := x)
tibble("{name}" := x)
}

But deep-forcing names isn't supported:\preformatted{exprs(this(is(deep("{name}" := x))))
}

}

